#!/usr/bin/env python3
"""
Generates a large Gradle 8 project with 100 modules, each ~100,000 lines of Java.
Run from the workspace root directory: python3 generate_project.py
"""

import os
import sys
from pathlib import Path

NUM_MODULES = 100
CLASSES_PER_MODULE = 100  # ~1000 lines each => ~100,000 lines per module


# ============================================================
# Gradle file content
# ============================================================

def make_settings():
    modules = ",\n".join(f'    "module-{i:02d}"' for i in range(1, NUM_MODULES + 1))
    return f'''rootProject.name = "gradle-baddie"

include(
{modules}
)
'''


ROOT_BUILD_KTS = '''\
plugins {
    id("org.sonarqube") version "4.4.1.3373"
}

allprojects {
    group = "com.example"
    version = "1.0.0"

    repositories {
        mavenCentral()
    }
}

subprojects {
    apply(plugin = "java")

    extensions.configure<JavaPluginExtension> {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    tasks.withType<JavaCompile> {
        options.encoding = "UTF-8"
    }
}

sonarqube {
    properties {
        property("sonar.projectKey", "gradle-baddie")
        property("sonar.organization", "your-sonarcloud-organization")
        property("sonar.host.url", "https://sonarcloud.io")
        property("sonar.sources", "src/main/java")
        property("sonar.java.binaries", "**/build/classes/java/main")
        property("sonar.sourceEncoding", "UTF-8")
    }
}
'''

MODULE_BUILD_KTS = '''\
plugins {
    java
}

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

tasks.withType<JavaCompile> {
    options.encoding = "UTF-8"
}
'''

GRADLE_WRAPPER_PROPS = '''\
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\\://services.gradle.org/distributions/gradle-8.8-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
'''

GRADLEW = '''\
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

##############################################################################
#
#   Gradle start up script for POSIX generated by "Gradle Wrapper" task
#   in the Gradle project.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other POSIX-compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for users on HPC systems:
#
#   To use this wrapper correctly on HPC systems, you are encouraged to source
#   the Gradle wrapper before running Gradle commands. For example:
#
#           source ./gradlew && gradlew build
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;;  #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is reliable for all platforms.
APP_HOME=$( cd "${APP_HOME:-./}" && pwd -P ) || exit

APP_NAME="Gradle"
APP_BASE_NAME=${0##*/}

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS=\'"-Xmx64m" "-Xms64m"\'

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be \'true\' or \'false\').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM\'s JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no \'java\' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That\'s why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
        ;;
    esac
    case $MAX_FD in  #(
      \'\' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That\'s why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, following shell quoting and substitution rules
eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$@"

exec "$JAVACMD" "$@"
'''

GRADLEW_BAT = '''\
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no \'java\' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\\gradle\\wrapper\\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega
'''


# ============================================================
# Java code generation
# ============================================================

# 30 fields: (name, type, default_expr)
FIELDS = [
    ("name",            "String",                       '""'),
    ("description",     "String",                       '""'),
    ("code",            "String",                       '""'),
    ("label",           "String",                       '""'),
    ("category",        "String",                       '"GENERAL"'),
    ("count",           "int",                          "0"),
    ("total",           "long",                         "0L"),
    ("score",           "double",                       "0.0"),
    ("ratio",           "double",                       "0.0"),
    ("active",          "boolean",                      "false"),
    ("enabled",         "boolean",                      "true"),
    ("index",           "int",                          "0"),
    ("priority",        "Integer",                      "null"),
    ("weight",          "Long",                         "null"),
    ("amount",          "java.math.BigDecimal",         "java.math.BigDecimal.ZERO"),
    ("threshold",       "Double",                       "null"),
    ("createdDate",     "java.time.LocalDate",          "java.time.LocalDate.now()"),
    ("updatedAt",       "java.time.LocalDateTime",      "java.time.LocalDateTime.now()"),
    ("expiryDate",      "java.util.Date",               "new java.util.Date()"),
    ("id",              "java.util.UUID",               "java.util.UUID.randomUUID()"),
    ("tags",            "java.util.List<String>",       "new java.util.ArrayList<>()"),
    ("metadata",        "java.util.Map<String,Object>", "new java.util.HashMap<>()"),
    ("flags",           "java.util.Set<String>",        "new java.util.HashSet<>()"),
    ("version",         "int",                          "1"),
    ("retryCount",      "int",                          "0"),
    ("maxRetries",      "int",                          "3"),
    ("timeout",         "long",                         "30000L"),
    ("checksum",        "String",                       '""'),
    ("source",          "String",                       '"UNKNOWN"'),
    ("target",          "String",                       '""'),
]

FIELD_NAMES = [f[0] for f in FIELDS]


def cap(s):
    return s[0].upper() + s[1:] if s else s


def getter_setter(field_name, field_type):
    method_name = cap(field_name)
    lines = []
    lines.append(f"    public {field_type} get{method_name}() {{")
    lines.append(f"        return {field_name};")
    lines.append(f"    }}")
    lines.append(f"")
    lines.append(f"    public void set{method_name}({field_type} {field_name}) {{")
    lines.append(f"        this.{field_name} = {field_name};")
    lines.append(f"    }}")
    lines.append(f"")
    return "\n".join(lines)


def method_process_string(n, mod, cls):
    """String transformation method ~33 lines."""
    seed = (mod * 31 + cls * 7 + n) % 5
    trim_field = FIELD_NAMES[seed]
    max_const = 512 + n * 64
    return f"""\
    /**
     * Processes raw string input applying tokenization and casing rules.
     * Module {mod:02d}, class {cls:03d}, variant {n}.
     *
     * @param input the raw input string
     * @param trim  whether to trim whitespace from tokens
     * @param maxLen maximum character length of the result
     * @return processed string, never null
     */
    public String processStringValue{n:02d}(String input, boolean trim, int maxLen) {{
        if (input == null) {{
            return {trim_field} != null ? {trim_field}.toString() : "";
        }}
        int effectiveMax = maxLen > 0 ? Math.min(maxLen, {max_const}) : {max_const};
        String working = trim ? input.trim() : input;
        if (working.isEmpty()) {{
            return "";
        }}
        StringBuilder sb = new StringBuilder(effectiveMax);
        String[] tokens = working.split("[\\\\s,;|]+");
        for (int i = 0; i < tokens.length; i++) {{
            String tok = tokens[i];
            if (tok == null || tok.isEmpty()) {{
                continue;
            }}
            if (sb.length() + tok.length() + 1 > effectiveMax) {{
                break;
            }}
            if (sb.length() > 0) {{
                sb.append(' ');
            }}
            sb.append(Character.toUpperCase(tok.charAt(0)));
            if (tok.length() > 1) {{
                sb.append(tok.substring(1).toLowerCase());
            }}
        }}
        return sb.toString();
    }}

"""


def method_compute_numeric(n, mod, cls):
    """Weighted metric computation method ~34 lines."""
    scale = 1.0 + (mod + cls + n) % 10 * 0.1
    offset = (mod * cls + n) % 100
    return f"""\
    /**
     * Computes a weighted numeric metric from an array of samples.
     * Module {mod:02d}, class {cls:03d}, variant {n}.
     *
     * @param samples  array of sample values
     * @param weights  optional weight array; uniform weights used if null
     * @param baseScale scaling multiplier applied to the result
     * @return weighted metric or 0.0 if samples is null/empty
     */
    public double computeNumericValue{n:02d}(double[] samples, double[] weights, double baseScale) {{
        if (samples == null || samples.length == 0) {{
            return 0.0;
        }}
        double wSum = 0.0;
        double wTotal = 0.0;
        double min = Double.MAX_VALUE;
        double max = -Double.MAX_VALUE;
        int effectiveLen = weights != null ? Math.min(samples.length, weights.length) : samples.length;
        for (int i = 0; i < effectiveLen; i++) {{
            if (Double.isNaN(samples[i]) || Double.isInfinite(samples[i])) {{
                continue;
            }}
            double w = (weights != null) ? Math.abs(weights[i]) : 1.0;
            wSum += samples[i] * w;
            wTotal += w;
            if (samples[i] < min) min = samples[i];
            if (samples[i] > max) max = samples[i];
        }}
        if (wTotal < 1e-9) {{
            return 0.0;
        }}
        double mean = wSum / wTotal;
        double range = max - min;
        double scaled = mean * baseScale * {scale:.2f} + {offset};
        return Double.isNaN(scaled) ? 0.0 : scaled;
    }}

"""


def method_filter_collection(n, mod, cls):
    """Collection filtering and sorting method ~34 lines."""
    min_len = 1 + (mod + cls + n) % 5
    max_items = 50 + (mod * cls + n) % 200
    return f"""\
    /**
     * Filters and sorts a list of string items by prefix and minimum length.
     * Module {mod:02d}, class {cls:03d}, variant {n}.
     *
     * @param items      source list, may be null
     * @param prefix     required prefix filter; null means no prefix restriction
     * @param minLength  minimum item length (after trimming)
     * @return unmodifiable sorted list of matching items
     */
    public java.util.List<String> filterCollection{n:02d}(
            java.util.List<String> items, String prefix, int minLength) {{
        java.util.List<String> result = new java.util.ArrayList<>();
        if (items == null || items.isEmpty()) {{
            return java.util.Collections.unmodifiableList(result);
        }}
        int effectiveMin = Math.max(minLength, {min_len});
        int limit = {max_items};
        for (String item : items) {{
            if (result.size() >= limit) {{
                break;
            }}
            if (item == null) {{
                continue;
            }}
            String trimmed = item.trim();
            if (trimmed.length() < effectiveMin) {{
                continue;
            }}
            if (prefix != null && !trimmed.startsWith(prefix)) {{
                continue;
            }}
            result.add(trimmed);
        }}
        result.sort(String.CASE_INSENSITIVE_ORDER);
        return java.util.Collections.unmodifiableList(result);
    }}

"""


def method_validate(n, mod, cls):
    """Field validation method ~36 lines."""
    max_name_len = 64 + (mod + cls + n) % 192
    max_count = 1000 + (mod * cls + n) % 9000
    return f"""\
    /**
     * Validates this instance's fields against business rules.
     * Module {mod:02d}, class {cls:03d}, variant {n}.
     *
     * @param strict when true, applies extended validation constraints
     * @return null if valid, otherwise a human-readable error message
     */
    public String performValidation{n:02d}(boolean strict) {{
        java.util.List<String> errs = new java.util.ArrayList<>();
        if (name == null || name.trim().isEmpty()) {{
            errs.add("name must not be blank");
        }}
        if (code == null || code.trim().isEmpty()) {{
            errs.add("code must not be blank");
        }}
        if (count < 0) {{
            errs.add("count must be >= 0, got: " + count);
        }}
        if (score < 0.0 || score > 1.0) {{
            errs.add("score must be in [0.0, 1.0], got: " + score);
        }}
        if (amount != null && amount.compareTo(java.math.BigDecimal.ZERO) < 0) {{
            errs.add("amount must be non-negative");
        }}
        if (strict) {{
            if (name != null && name.length() > {max_name_len}) {{
                errs.add("name exceeds max length of {max_name_len}");
            }}
            if (count > {max_count}) {{
                errs.add("count exceeds max of {max_count}");
            }}
            if (timeout <= 0) {{
                errs.add("timeout must be positive");
            }}
            if (retryCount > maxRetries) {{
                errs.add("retryCount (" + retryCount + ") exceeds maxRetries (" + maxRetries + ")");
            }}
        }}
        if (errs.isEmpty()) {{
            return null;
        }}
        StringBuilder sb = new StringBuilder("Validation failed: ");
        for (int i = 0; i < errs.size(); i++) {{
            if (i > 0) sb.append("; ");
            sb.append(errs.get(i));
        }}
        return sb.toString();
    }}

"""


def method_build_map(n, mod, cls):
    """Metadata map construction method ~35 lines."""
    prefix_default = f"m{mod:02d}c{cls:03d}v{n:02d}"
    return f"""\
    /**
     * Assembles a property map from the current field state.
     * Module {mod:02d}, class {cls:03d}, variant {n}.
     *
     * @param includeNulls when true, null-valued fields are included in the result
     * @param keyPrefix    optional prefix prepended to every key
     * @return immutable property map
     */
    public java.util.Map<String, Object> buildPropertyMap{n:02d}(boolean includeNulls, String keyPrefix) {{
        java.util.Map<String, Object> map = new java.util.LinkedHashMap<>();
        String pfx = (keyPrefix != null && !keyPrefix.isEmpty()) ? keyPrefix + "." : "{prefix_default}.";
        putEntry(map, pfx + "name",        name,        includeNulls);
        putEntry(map, pfx + "code",        code,        includeNulls);
        putEntry(map, pfx + "category",    category,    includeNulls);
        putEntry(map, pfx + "label",       label,       includeNulls);
        putEntry(map, pfx + "count",       count,       includeNulls);
        putEntry(map, pfx + "total",       total,       includeNulls);
        putEntry(map, pfx + "score",       score,       includeNulls);
        putEntry(map, pfx + "active",      active,      includeNulls);
        putEntry(map, pfx + "enabled",     enabled,     includeNulls);
        putEntry(map, pfx + "source",      source,      includeNulls);
        putEntry(map, pfx + "target",      target,      includeNulls);
        putEntry(map, pfx + "version",     version,     includeNulls);
        putEntry(map, pfx + "priority",    priority,    includeNulls);
        putEntry(map, pfx + "amount",      amount,      includeNulls);
        putEntry(map, pfx + "id",          id != null ? id.toString() : null, includeNulls);
        putEntry(map, pfx + "createdDate", createdDate != null ? createdDate.toString() : null, includeNulls);
        if (tags != null && !tags.isEmpty()) {{
            map.put(pfx + "tags.size", tags.size());
        }}
        if (metadata != null && !metadata.isEmpty()) {{
            map.put(pfx + "metadata.keys", new java.util.ArrayList<>(metadata.keySet()));
        }}
        return java.util.Collections.unmodifiableMap(map);
    }}

"""


METHOD_GENERATORS = [
    method_process_string,
    method_compute_numeric,
    method_filter_collection,
    method_validate,
    method_build_map,
]


def generate_java_class(module_id: int, class_id: int) -> tuple:
    """Return (class_name, java_source_code) for the given module/class IDs."""
    type_names = ["Entity", "Service", "Util", "Repository", "Controller"]
    type_name = type_names[(class_id - 1) % len(type_names)]
    class_name = f"Generated{type_name}{module_id:02d}{class_id:03d}"
    pkg = f"com.example.module{module_id:02d}"

    lines = []

    # --- Header ---
    lines.append(f"package {pkg};")
    lines.append("")
    lines.append("import java.util.ArrayList;")
    lines.append("import java.util.Collections;")
    lines.append("import java.util.HashMap;")
    lines.append("import java.util.HashSet;")
    lines.append("import java.util.LinkedHashMap;")
    lines.append("import java.util.List;")
    lines.append("import java.util.Map;")
    lines.append("import java.util.Objects;")
    lines.append("import java.util.Set;")
    lines.append("import java.util.UUID;")
    lines.append("import java.math.BigDecimal;")
    lines.append("import java.time.LocalDate;")
    lines.append("import java.time.LocalDateTime;")
    lines.append("")

    # --- Class javadoc ---
    lines.append("/**")
    lines.append(f" * {class_name} - auto-generated class for module {module_id:02d}.")
    lines.append(f" * Type: {type_name}. Class index: {class_id:03d}.")
    lines.append(f" * Part of the Gradle Baddie large-project benchmark suite.")
    lines.append(f" *")
    lines.append(f" * <p>This class provides domain logic and data management capabilities")
    lines.append(f" * for the {pkg} package.</p>")
    lines.append(f" *")
    lines.append(f" * @since 1.0.0")
    lines.append(f" */")

    # --- Class declaration ---
    lines.append(f"public class {class_name} implements java.io.Serializable {{")
    lines.append("")

    # --- serialVersionUID ---
    serial = module_id * 1_000_000 + class_id
    lines.append(f"    private static final long serialVersionUID = {serial}L;")
    lines.append("")

    # --- Constants ---
    lines.append(f"    /** Maximum allowed size for collection fields. */")
    lines.append(f"    public static final int MAX_SIZE = {1000 + (module_id * class_id) % 9000};")
    lines.append(f"    /** Default category label. */")
    lines.append(f'    public static final String DEFAULT_CATEGORY = "MODULE_{module_id:02d}";')
    lines.append(f"    /** Epsilon for floating-point comparisons. */")
    lines.append(f"    public static final double EPSILON = 1e-9;")
    lines.append(f"    /** Module identifier constant. */")
    lines.append(f'    public static final String MODULE_ID = "module-{module_id:02d}";')
    lines.append(f"    /** Class identifier constant. */")
    lines.append(f"    public static final int CLASS_ID = {class_id};")
    lines.append("")

    # --- Fields ---
    lines.append("    // ---- Instance fields ----")
    for fname, ftype, _ in FIELDS:
        lines.append(f"    private {ftype} {fname};")
    lines.append("")

    # --- Status enum ---
    lines.append("    /**")
    lines.append(f"     * Lifecycle status for {class_name}.")
    lines.append("     */")
    lines.append("    public enum Status {")
    lines.append("        CREATED, PENDING, PROCESSING, COMPLETED, FAILED, CANCELLED, ARCHIVED;")
    lines.append("")
    lines.append("        /** Returns true if this is a terminal status. */")
    lines.append("        public boolean isTerminal() {")
    lines.append("            return this == COMPLETED || this == FAILED || this == CANCELLED || this == ARCHIVED;")
    lines.append("        }")
    lines.append("")
    lines.append("        /** Returns true if this status represents active processing. */")
    lines.append("        public boolean isActive() {")
    lines.append("            return this == PENDING || this == PROCESSING;")
    lines.append("        }")
    lines.append("    }")
    lines.append("")
    lines.append("    private Status status;")
    lines.append("")

    # --- Static initializer ---
    lines.append("    static {")
    lines.append(f'        String prop = System.getProperty("{pkg}.{class_name}.init", "false");')
    lines.append(f'        if ("true".equalsIgnoreCase(prop)) {{')
    lines.append(f'            System.getLogger("{class_name}").log(System.Logger.Level.DEBUG, "Static init");')
    lines.append("        }")
    lines.append("    }")
    lines.append("")

    # --- Default constructor ---
    lines.append("    /** Creates a new instance with default field values. */")
    lines.append(f"    public {class_name}() {{")
    lines.append(f'        this.name = "";')
    lines.append(f'        this.description = "";')
    lines.append(f'        this.code = MODULE_ID + "-" + CLASS_ID;')
    lines.append(f'        this.category = DEFAULT_CATEGORY;')
    lines.append(f'        this.source = "UNKNOWN";')
    lines.append(f'        this.tags = new ArrayList<>();')
    lines.append(f'        this.metadata = new HashMap<>();')
    lines.append(f'        this.flags = new HashSet<>();')
    lines.append(f'        this.amount = BigDecimal.ZERO;')
    lines.append(f'        this.createdDate = LocalDate.now();')
    lines.append(f'        this.updatedAt = LocalDateTime.now();')
    lines.append(f'        this.expiryDate = new java.util.Date();')
    lines.append(f'        this.id = UUID.randomUUID();')
    lines.append(f'        this.status = Status.CREATED;')
    lines.append(f'        this.enabled = true;')
    lines.append(f'        this.maxRetries = 3;')
    lines.append(f'        this.timeout = 30000L;')
    lines.append(f'        this.version = 1;')
    lines.append("    }")
    lines.append("")

    # --- Parameterized constructor ---
    lines.append("    /**")
    lines.append("     * Creates a new instance with the provided core field values.")
    lines.append("     *")
    lines.append("     * @param name     the human-readable name")
    lines.append("     * @param code     the unique code identifier")
    lines.append("     * @param category the classification category")
    lines.append("     * @param active   whether this instance is active")
    lines.append("     */")
    lines.append(f"    public {class_name}(String name, String code, String category, boolean active) {{")
    lines.append("        this();")
    lines.append("        this.name = name;")
    lines.append("        this.code = code;")
    lines.append("        this.category = category;")
    lines.append("        this.active = active;")
    lines.append("        this.status = active ? Status.PENDING : Status.CREATED;")
    lines.append("    }")
    lines.append("")

    # --- Status getter/setter ---
    lines.append("    public Status getStatus() { return status; }")
    lines.append("    public void setStatus(Status status) { this.status = status; }")
    lines.append("")

    # --- Getters / setters for all 30 fields ---
    lines.append("    // ---- Accessors ----")
    lines.append("")
    for fname, ftype, _ in FIELDS:
        lines.append(getter_setter(fname, ftype))

    # --- 20 business methods (5 templates × 4 repetitions) ---
    lines.append("    // ---- Business methods ----")
    lines.append("")
    for rep in range(1, 5):          # 4 repetitions → n = 1..4, 5..8, 9..12, 13..16
        for gen_idx, gen_fn in enumerate(METHOD_GENERATORS):
            n = (rep - 1) * len(METHOD_GENERATORS) + gen_idx + 1
            lines.append(gen_fn(n, module_id, class_id))

    # --- putEntry helper (used by buildPropertyMap variants) ---
    lines.append("    // ---- Internal helpers ----")
    lines.append("")
    lines.append("    private void putEntry(java.util.Map<String, Object> map, String key, Object value, boolean inclNull) {")
    lines.append("        if (value != null || inclNull) {")
    lines.append("            map.put(key, value);")
    lines.append("        }")
    lines.append("    }")
    lines.append("")

    # --- equals / hashCode / toString ---
    lines.append("    // ---- Object overrides ----")
    lines.append("")
    lines.append("    @Override")
    lines.append("    public boolean equals(Object obj) {")
    lines.append("        if (this == obj) return true;")
    lines.append("        if (obj == null || getClass() != obj.getClass()) return false;")
    lines.append(f"        {class_name} other = ({class_name}) obj;")
    lines.append("        return Objects.equals(id, other.id)")
    lines.append("            && Objects.equals(code, other.code)")
    lines.append("            && Objects.equals(name, other.name)")
    lines.append("            && version == other.version;")
    lines.append("    }")
    lines.append("")
    lines.append("    @Override")
    lines.append("    public int hashCode() {")
    lines.append("        return Objects.hash(id, code, name, version);")
    lines.append("    }")
    lines.append("")
    lines.append("    @Override")
    lines.append("    public String toString() {")
    lines.append(f'        return "{class_name}{{" +')
    lines.append(f'            "id=" + id +')
    lines.append(f'            ", code=\'" + code + \'\\\'\' +')
    lines.append(f'            ", name=\'" + name + \'\\\'\' +')
    lines.append(f'            ", category=\'" + category + \'\\\'\' +')
    lines.append(f'            ", status=" + status +')
    lines.append(f'            ", active=" + active +')
    lines.append(f'            ", version=" + version +')
    lines.append(f"            '}}';")
    lines.append("    }")
    lines.append("")

    # --- Closing brace ---
    lines.append("}")

    return class_name, "\n".join(lines)


# ============================================================
# Main
# ============================================================

def main():
    root = Path(".")

    print("=== Gradle Baddie Project Generator ===")
    print(f"Modules: {NUM_MODULES}  |  Classes/module: {CLASSES_PER_MODULE}")
    print(f"Target: ~{CLASSES_PER_MODULE * 1000:,} lines/module  |  ~{NUM_MODULES * CLASSES_PER_MODULE * 1000 // 1_000_000}M total lines")
    print()

    # ---- Root settings.gradle.kts ----
    print("Writing settings.gradle.kts ...", flush=True)
    (root / "settings.gradle.kts").write_text(make_settings())

    # ---- Root build.gradle.kts ----
    print("Writing build.gradle.kts ...", flush=True)
    (root / "build.gradle.kts").write_text(ROOT_BUILD_KTS)

    # ---- Gradle wrapper files ----
    wrapper_dir = root / "gradle" / "wrapper"
    wrapper_dir.mkdir(parents=True, exist_ok=True)
    print("Writing gradle wrapper properties ...", flush=True)
    (wrapper_dir / "gradle-wrapper.properties").write_text(GRADLE_WRAPPER_PROPS)
    (root / "gradlew").write_text(GRADLEW)
    (root / "gradlew.bat").write_text(GRADLEW_BAT)
    os.chmod(root / "gradlew", 0o755)

    # ---- Modules ----
    total_files = 0
    for mod in range(1, NUM_MODULES + 1):
        module_name = f"module-{mod:02d}"
        pkg_name = f"com.example.module{mod:02d}"
        pkg_rel = pkg_name.replace(".", "/")
        src_dir = root / module_name / "src" / "main" / "java" / pkg_rel
        src_dir.mkdir(parents=True, exist_ok=True)

        # module build.gradle.kts
        (root / module_name / "build.gradle.kts").write_text(MODULE_BUILD_KTS)

        # Java source files
        for cls in range(1, CLASSES_PER_MODULE + 1):
            class_name, source = generate_java_class(mod, cls)
            (src_dir / f"{class_name}.java").write_text(source)
            total_files += 1

        line_count = CLASSES_PER_MODULE * 1000  # approximate
        print(f"  [{mod:03d}/{NUM_MODULES}] {module_name}: {CLASSES_PER_MODULE} classes (~{line_count:,} lines)", flush=True)

    print()
    print(f"Done! Generated {total_files:,} Java source files across {NUM_MODULES} modules.")
    print()
    print("Next steps:")
    print("  1. Bootstrap the Gradle wrapper JAR:")
    print("       gradle wrapper --gradle-version 8.8")
    print("     (or use the wrapper from an existing Gradle 8 project)")
    print()
    print("  2. Build the project:")
    print("       ./gradlew build")
    print()
    print("  3. Scan with SonarCloud (set SONAR_TOKEN env var first):")
    print("       ./gradlew sonarqube \\")
    print("         -Dsonar.projectKey=gradle-baddie \\")
    print("         -Dsonar.organization=<your-org> \\")
    print("         -Dsonar.token=$SONAR_TOKEN")


if __name__ == "__main__":
    main()
